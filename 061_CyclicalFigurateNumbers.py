# 061 Cyclical Figurate Numbers
#
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are
# generated by the following formula:
#
# Triangle   - P3n = n(n + 1)/2
# Square     - P4n = n^2
# Pentagonal - P5n = n(3n -1)/2
# Hexagonal  - P6n = n(2n -1)
# Heptagonal - P7n = n(5n - 3)/2
# Octagonal  - P8n = n(3n-2)
# 
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
# 1 . The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last
# number wth the first).
# 2. Each polygonal type: triangle (P3,127 = 8128), square (P4,91 = 8281), and pentagonal (P5,44 = 2882), is represented by a
# different number in the set.
# 3. This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal,
# hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

import numpy as np
from itertools import combinations, permutations
from itertools import product
from decimal import Decimal
import time
import sys

def percent_complete(step, total_steps, start_time, bar_width=60, title="",  print_perc=True, print_time=True):
    # global last_print
    # me = last_print
    # if time.time() - me > 0.1 and step != total_steps:
    #     last_print = time.time()
    # else:
    #     return

    # UTF-8 left blocks: 1, 1/8, 1/4, 3/8, 1/2, 5/8, 3/4, 7/8
    utf_8s = ["█", "▏", "▎", "▍", "▌", "▋", "▊", "█"]
    perc = 100 * float(step) / float(total_steps)
    max_ticks = bar_width * 8
    num_ticks = int(round(perc / 100 * max_ticks))
    full_ticks = num_ticks / 8      # Number of full blocks
    part_ticks = num_ticks % 8      # Size of partial block (array index)
    
    disp = bar = ""                 # Blank out variables
    bar += utf_8s[0] * int(full_ticks)  # Add full blocks into Progress Bar
    
    # If part_ticks is zero, then no partial block, else append part char
    if part_ticks > 0:
        bar += utf_8s[part_ticks]
    
    # Pad Progress Bar with fill character
    bar += "▒" * int((max_ticks/8 - float(num_ticks)/8.0))
    
    if len(title) > 0:
        disp = title + ": "         # Optional title to progress display
    
    # Print progress bar in green: https://stackoverflow.com/a/21786287/6929343
    disp += "\x1b[0;32m"            # Color Green
    disp += bar                     # Progress bar to progress display
    disp += "\x1b[0m"               # Color Reset
    if print_perc:
        # If requested, append percentage complete to progress display
        if perc > 100.0:
            perc = 100.0            # Fix "100.04 %" rounding error
        disp += " {:6.2f}".format(perc) + " %"

    if print_time:
        disp += "  eta: " + '{0:02.0f}:{1:02.0f}'.format(*divmod((time.time()-start_time) * 60, 60))
      

    # Output to terminal repetitively over the same line using '\r'.
    sys.stdout.write("\r" + disp)
    sys.stdout.flush()

# Triangle   - P3n = n(n + 1)/2
def TriangleNumberGen(s,f):
    res = []
    i = 0
    while True:
        nxt = int((i*(i+1))/2)
        if nxt >= s and nxt <= f:
            res.append((3, nxt))
            
        if nxt > f:
            return res
        i+=1

#print("Triangle ",TriangleNumberGen(1,100))

# Square     - P4n = n^2
def SquareNumberGen(s,f):
    res = []
    i = 0
    while True:
        nxt = int(i*i)
        if nxt >= s and nxt <= f:
            res.append((4,nxt))
            
        if nxt > f:
            return res
        i+=1
#print("Square ",SquareNumberGen(1,100))

# Pentagonal - P5n = n(3n -1)/2
def PentagonalNumberGen(s,f):
    res = []
    i = 0
    while True:
        nxt = int((i*((3*i)-1))/2)
        if nxt >= s and nxt <= f:
            res.append((5,nxt))
            
        if nxt > f:
            return res
        i+=1
#print("Pentagonal ", PentagonalNumberGen(1,100))

# Hexagonal  - P6n = n(2n -1)
def HexagonalNumberGen(s,f):
    res = []
    i = 0
    while True:
        nxt = int((i*((2*i)-1)))
        if nxt >= s and nxt <= f:
            res.append((6, nxt))
            
        if nxt > f:
            return res
        i+=1
#print("Hexagonal ",HexagonalNumberGen(1,100))

# Heptagonal - P7n = n(5n - 3)/2
def HeptagonalNumberGen(s,f):
    res = []
    i = 0
    while True:
        nxt = int((i*((5*i)-3))/2)
        if nxt >= s and nxt <= f:
            res.append((7,nxt))
            
        if nxt > f:
            return res
        i+=1
#print("Heptagonal ", HeptagonalNumberGen(1,100))

# Octagonal  - P8n = n(3n-2)
def OctagonalNumberGen(s,f):
    res = []
    i = 0
    while True:
        nxt = int(i*((3*i)-2))
        if nxt >= s and nxt <= f:
            res.append((8,nxt))
            
        if nxt > f:
            return res
        i+=1
#print("Octagonal ", OctagonalNumberGen(1,100))

def IsCyclic(arr):

    perm = list(permutations(arr, len(arr)))
    

    for j in range(len(perm)):
        res = True
        a = str(perm[j][0])[:2]
        b = str(perm[j][len(arr)-1])[2:]
        if str(perm[j][0])[:2] != str(perm[j][len(arr)-1])[2:]:
            res = False
            continue
        else:
             for i in range(len(arr)-1):
                a = str(perm[j][i])[2:] 
                b = str(perm[j][i+1])[:2]
                if a != b:
                    res = False
                    break
        if res: 
            return True
        
    return False


print(IsCyclic([8128, 8281,2882]))



def next(types, data, ds):
    if len(types) == 6 and data[0] // 100 == data[-1] % 100:
        print(data, sum(data))
    else:
        for t, n in ds.get((types[-1], data[-1]), []):
            if t not in types:
                next(types+[t], data+[n], ds)


# First I try to reproduce the set of three cyclic 4-digit number
def ThreeCyclic():
    start_time = time.time()
    # Generation
    generated = []
    generated.extend(TriangleNumberGen(999,9999))
    generated.extend(SquareNumberGen(999, 9999))
    generated.extend(PentagonalNumberGen(999, 9999))
    generated.extend(HexagonalNumberGen(1000, 9999))
    generated.extend(HeptagonalNumberGen(1000, 9999))
    generated.extend(OctagonalNumberGen(1000, 9999))

    cyclicalSet = {}
    for t1, n1 in generated:
        for t2, n2 in generated:
            if t1 != t2 and n1 % 100 == n2 // 100:
                cyclicalSet[t1, n1] = cyclicalSet.get((t1, n1),[]) + [(t2, n2)] 

    for type, data in cyclicalSet: next([type], [data], cyclicalSet)

    # for _set in cyclicalSet:
    #     if len(_set) == 6 and _set[0] // 100 == _set[-1] % 100:
    #         print(_set, sum(_set))   
                                    
ThreeCyclic()